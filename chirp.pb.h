// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chirp.proto

#ifndef PROTOBUF_INCLUDED_chirp_2eproto
#define PROTOBUF_INCLUDED_chirp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_chirp_2eproto 

namespace protobuf_chirp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_chirp_2eproto
namespace chirp {
class Chirp;
class ChirpDefaultTypeInternal;
extern ChirpDefaultTypeInternal _Chirp_default_instance_;
class ChirpReply;
class ChirpReplyDefaultTypeInternal;
extern ChirpReplyDefaultTypeInternal _ChirpReply_default_instance_;
class ChirpRequest;
class ChirpRequestDefaultTypeInternal;
extern ChirpRequestDefaultTypeInternal _ChirpRequest_default_instance_;
class DeleteReply;
class DeleteReplyDefaultTypeInternal;
extern DeleteReplyDefaultTypeInternal _DeleteReply_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class FollowReply;
class FollowReplyDefaultTypeInternal;
extern FollowReplyDefaultTypeInternal _FollowReply_default_instance_;
class FollowRequest;
class FollowRequestDefaultTypeInternal;
extern FollowRequestDefaultTypeInternal _FollowRequest_default_instance_;
class GetReply;
class GetReplyDefaultTypeInternal;
extern GetReplyDefaultTypeInternal _GetReply_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class MonitorReply;
class MonitorReplyDefaultTypeInternal;
extern MonitorReplyDefaultTypeInternal _MonitorReply_default_instance_;
class MonitorRequest;
class MonitorRequestDefaultTypeInternal;
extern MonitorRequestDefaultTypeInternal _MonitorRequest_default_instance_;
class PutReply;
class PutReplyDefaultTypeInternal;
extern PutReplyDefaultTypeInternal _PutReply_default_instance_;
class PutRequest;
class PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class ReadReply;
class ReadReplyDefaultTypeInternal;
extern ReadReplyDefaultTypeInternal _ReadReply_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class RegisterReply;
class RegisterReplyDefaultTypeInternal;
extern RegisterReplyDefaultTypeInternal _RegisterReply_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace chirp
namespace google {
namespace protobuf {
template<> ::chirp::Chirp* Arena::CreateMaybeMessage<::chirp::Chirp>(Arena*);
template<> ::chirp::ChirpReply* Arena::CreateMaybeMessage<::chirp::ChirpReply>(Arena*);
template<> ::chirp::ChirpRequest* Arena::CreateMaybeMessage<::chirp::ChirpRequest>(Arena*);
template<> ::chirp::DeleteReply* Arena::CreateMaybeMessage<::chirp::DeleteReply>(Arena*);
template<> ::chirp::DeleteRequest* Arena::CreateMaybeMessage<::chirp::DeleteRequest>(Arena*);
template<> ::chirp::FollowReply* Arena::CreateMaybeMessage<::chirp::FollowReply>(Arena*);
template<> ::chirp::FollowRequest* Arena::CreateMaybeMessage<::chirp::FollowRequest>(Arena*);
template<> ::chirp::GetReply* Arena::CreateMaybeMessage<::chirp::GetReply>(Arena*);
template<> ::chirp::GetRequest* Arena::CreateMaybeMessage<::chirp::GetRequest>(Arena*);
template<> ::chirp::MonitorReply* Arena::CreateMaybeMessage<::chirp::MonitorReply>(Arena*);
template<> ::chirp::MonitorRequest* Arena::CreateMaybeMessage<::chirp::MonitorRequest>(Arena*);
template<> ::chirp::PutReply* Arena::CreateMaybeMessage<::chirp::PutReply>(Arena*);
template<> ::chirp::PutRequest* Arena::CreateMaybeMessage<::chirp::PutRequest>(Arena*);
template<> ::chirp::ReadReply* Arena::CreateMaybeMessage<::chirp::ReadReply>(Arena*);
template<> ::chirp::ReadRequest* Arena::CreateMaybeMessage<::chirp::ReadRequest>(Arena*);
template<> ::chirp::RegisterReply* Arena::CreateMaybeMessage<::chirp::RegisterReply>(Arena*);
template<> ::chirp::RegisterRequest* Arena::CreateMaybeMessage<::chirp::RegisterRequest>(Arena*);
template<> ::chirp::Timestamp* Arena::CreateMaybeMessage<::chirp::Timestamp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chirp {

// ===================================================================

class PutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.PutRequest) */ {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PutRequest* other);
  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutRequest* New() const final {
    return CreateMaybeMessage<PutRequest>(NULL);
  }

  PutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:chirp.PutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PutReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.PutReply) */ {
 public:
  PutReply();
  virtual ~PutReply();

  PutReply(const PutReply& from);

  inline PutReply& operator=(const PutReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutReply(PutReply&& from) noexcept
    : PutReply() {
    *this = ::std::move(from);
  }

  inline PutReply& operator=(PutReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutReply* internal_default_instance() {
    return reinterpret_cast<const PutReply*>(
               &_PutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PutReply* other);
  friend void swap(PutReply& a, PutReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutReply* New() const final {
    return CreateMaybeMessage<PutReply>(NULL);
  }

  PutReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PutReply& from);
  void MergeFrom(const PutReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.PutReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(NULL);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:chirp.GetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.GetReply) */ {
 public:
  GetReply();
  virtual ~GetReply();

  GetReply(const GetReply& from);

  inline GetReply& operator=(const GetReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetReply(GetReply&& from) noexcept
    : GetReply() {
    *this = ::std::move(from);
  }

  inline GetReply& operator=(GetReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetReply* internal_default_instance() {
    return reinterpret_cast<const GetReply*>(
               &_GetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetReply* other);
  friend void swap(GetReply& a, GetReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetReply* New() const final {
    return CreateMaybeMessage<GetReply>(NULL);
  }

  GetReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetReply& from);
  void MergeFrom(const GetReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:chirp.GetReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(NULL);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:chirp.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.DeleteReply) */ {
 public:
  DeleteReply();
  virtual ~DeleteReply();

  DeleteReply(const DeleteReply& from);

  inline DeleteReply& operator=(const DeleteReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteReply(DeleteReply&& from) noexcept
    : DeleteReply() {
    *this = ::std::move(from);
  }

  inline DeleteReply& operator=(DeleteReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteReply* internal_default_instance() {
    return reinterpret_cast<const DeleteReply*>(
               &_DeleteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DeleteReply* other);
  friend void swap(DeleteReply& a, DeleteReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteReply* New() const final {
    return CreateMaybeMessage<DeleteReply>(NULL);
  }

  DeleteReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteReply& from);
  void MergeFrom(const DeleteReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.DeleteReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(NULL);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // int64 useconds = 2;
  void clear_useconds();
  static const int kUsecondsFieldNumber = 2;
  ::google::protobuf::int64 useconds() const;
  void set_useconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:chirp.Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int64 useconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chirp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.Chirp) */ {
 public:
  Chirp();
  virtual ~Chirp();

  Chirp(const Chirp& from);

  inline Chirp& operator=(const Chirp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chirp(Chirp&& from) noexcept
    : Chirp() {
    *this = ::std::move(from);
  }

  inline Chirp& operator=(Chirp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chirp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chirp* internal_default_instance() {
    return reinterpret_cast<const Chirp*>(
               &_Chirp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Chirp* other);
  friend void swap(Chirp& a, Chirp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chirp* New() const final {
    return CreateMaybeMessage<Chirp>(NULL);
  }

  Chirp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chirp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chirp& from);
  void MergeFrom(const Chirp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chirp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // bytes id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes parent_id = 4;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_id(::std::string&& value);
  #endif
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  // .chirp.Timestamp timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  private:
  const ::chirp::Timestamp& _internal_timestamp() const;
  public:
  const ::chirp::Timestamp& timestamp() const;
  ::chirp::Timestamp* release_timestamp();
  ::chirp::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::chirp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:chirp.Chirp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  ::chirp::Timestamp* timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(NULL);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chirp.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.RegisterReply) */ {
 public:
  RegisterReply();
  virtual ~RegisterReply();

  RegisterReply(const RegisterReply& from);

  inline RegisterReply& operator=(const RegisterReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterReply(RegisterReply&& from) noexcept
    : RegisterReply() {
    *this = ::std::move(from);
  }

  inline RegisterReply& operator=(RegisterReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterReply* internal_default_instance() {
    return reinterpret_cast<const RegisterReply*>(
               &_RegisterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RegisterReply* other);
  friend void swap(RegisterReply& a, RegisterReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterReply* New() const final {
    return CreateMaybeMessage<RegisterReply>(NULL);
  }

  RegisterReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterReply& from);
  void MergeFrom(const RegisterReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.RegisterReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChirpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ChirpRequest) */ {
 public:
  ChirpRequest();
  virtual ~ChirpRequest();

  ChirpRequest(const ChirpRequest& from);

  inline ChirpRequest& operator=(const ChirpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChirpRequest(ChirpRequest&& from) noexcept
    : ChirpRequest() {
    *this = ::std::move(from);
  }

  inline ChirpRequest& operator=(ChirpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChirpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChirpRequest* internal_default_instance() {
    return reinterpret_cast<const ChirpRequest*>(
               &_ChirpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ChirpRequest* other);
  friend void swap(ChirpRequest& a, ChirpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChirpRequest* New() const final {
    return CreateMaybeMessage<ChirpRequest>(NULL);
  }

  ChirpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChirpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChirpRequest& from);
  void MergeFrom(const ChirpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChirpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // bytes parent_id = 3;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_id(::std::string&& value);
  #endif
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  // @@protoc_insertion_point(class_scope:chirp.ChirpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChirpReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ChirpReply) */ {
 public:
  ChirpReply();
  virtual ~ChirpReply();

  ChirpReply(const ChirpReply& from);

  inline ChirpReply& operator=(const ChirpReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChirpReply(ChirpReply&& from) noexcept
    : ChirpReply() {
    *this = ::std::move(from);
  }

  inline ChirpReply& operator=(ChirpReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChirpReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChirpReply* internal_default_instance() {
    return reinterpret_cast<const ChirpReply*>(
               &_ChirpReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ChirpReply* other);
  friend void swap(ChirpReply& a, ChirpReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChirpReply* New() const final {
    return CreateMaybeMessage<ChirpReply>(NULL);
  }

  ChirpReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChirpReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChirpReply& from);
  void MergeFrom(const ChirpReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChirpReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chirp.Chirp chirp = 1;
  bool has_chirp() const;
  void clear_chirp();
  static const int kChirpFieldNumber = 1;
  private:
  const ::chirp::Chirp& _internal_chirp() const;
  public:
  const ::chirp::Chirp& chirp() const;
  ::chirp::Chirp* release_chirp();
  ::chirp::Chirp* mutable_chirp();
  void set_allocated_chirp(::chirp::Chirp* chirp);

  // @@protoc_insertion_point(class_scope:chirp.ChirpReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chirp::Chirp* chirp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.FollowRequest) */ {
 public:
  FollowRequest();
  virtual ~FollowRequest();

  FollowRequest(const FollowRequest& from);

  inline FollowRequest& operator=(const FollowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowRequest(FollowRequest&& from) noexcept
    : FollowRequest() {
    *this = ::std::move(from);
  }

  inline FollowRequest& operator=(FollowRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowRequest* internal_default_instance() {
    return reinterpret_cast<const FollowRequest*>(
               &_FollowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FollowRequest* other);
  friend void swap(FollowRequest& a, FollowRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowRequest* New() const final {
    return CreateMaybeMessage<FollowRequest>(NULL);
  }

  FollowRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowRequest& from);
  void MergeFrom(const FollowRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string to_follow = 2;
  void clear_to_follow();
  static const int kToFollowFieldNumber = 2;
  const ::std::string& to_follow() const;
  void set_to_follow(const ::std::string& value);
  #if LANG_CXX11
  void set_to_follow(::std::string&& value);
  #endif
  void set_to_follow(const char* value);
  void set_to_follow(const char* value, size_t size);
  ::std::string* mutable_to_follow();
  ::std::string* release_to_follow();
  void set_allocated_to_follow(::std::string* to_follow);

  // @@protoc_insertion_point(class_scope:chirp.FollowRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr to_follow_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.FollowReply) */ {
 public:
  FollowReply();
  virtual ~FollowReply();

  FollowReply(const FollowReply& from);

  inline FollowReply& operator=(const FollowReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowReply(FollowReply&& from) noexcept
    : FollowReply() {
    *this = ::std::move(from);
  }

  inline FollowReply& operator=(FollowReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowReply* internal_default_instance() {
    return reinterpret_cast<const FollowReply*>(
               &_FollowReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(FollowReply* other);
  friend void swap(FollowReply& a, FollowReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowReply* New() const final {
    return CreateMaybeMessage<FollowReply>(NULL);
  }

  FollowReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowReply& from);
  void MergeFrom(const FollowReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chirp.FollowReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ReadRequest) */ {
 public:
  ReadRequest();
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ReadRequest* other);
  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return CreateMaybeMessage<ReadRequest>(NULL);
  }

  ReadRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes chirp_id = 1;
  void clear_chirp_id();
  static const int kChirpIdFieldNumber = 1;
  const ::std::string& chirp_id() const;
  void set_chirp_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chirp_id(::std::string&& value);
  #endif
  void set_chirp_id(const char* value);
  void set_chirp_id(const void* value, size_t size);
  ::std::string* mutable_chirp_id();
  ::std::string* release_chirp_id();
  void set_allocated_chirp_id(::std::string* chirp_id);

  // @@protoc_insertion_point(class_scope:chirp.ReadRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chirp_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.ReadReply) */ {
 public:
  ReadReply();
  virtual ~ReadReply();

  ReadReply(const ReadReply& from);

  inline ReadReply& operator=(const ReadReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadReply(ReadReply&& from) noexcept
    : ReadReply() {
    *this = ::std::move(from);
  }

  inline ReadReply& operator=(ReadReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadReply* internal_default_instance() {
    return reinterpret_cast<const ReadReply*>(
               &_ReadReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ReadReply* other);
  friend void swap(ReadReply& a, ReadReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadReply* New() const final {
    return CreateMaybeMessage<ReadReply>(NULL);
  }

  ReadReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadReply& from);
  void MergeFrom(const ReadReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chirp.Chirp chirps = 1;
  int chirps_size() const;
  void clear_chirps();
  static const int kChirpsFieldNumber = 1;
  ::chirp::Chirp* mutable_chirps(int index);
  ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >*
      mutable_chirps();
  const ::chirp::Chirp& chirps(int index) const;
  ::chirp::Chirp* add_chirps();
  const ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >&
      chirps() const;

  // @@protoc_insertion_point(class_scope:chirp.ReadReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::chirp::Chirp > chirps_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonitorRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.MonitorRequest) */ {
 public:
  MonitorRequest();
  virtual ~MonitorRequest();

  MonitorRequest(const MonitorRequest& from);

  inline MonitorRequest& operator=(const MonitorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonitorRequest(MonitorRequest&& from) noexcept
    : MonitorRequest() {
    *this = ::std::move(from);
  }

  inline MonitorRequest& operator=(MonitorRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorRequest* internal_default_instance() {
    return reinterpret_cast<const MonitorRequest*>(
               &_MonitorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MonitorRequest* other);
  friend void swap(MonitorRequest& a, MonitorRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonitorRequest* New() const final {
    return CreateMaybeMessage<MonitorRequest>(NULL);
  }

  MonitorRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonitorRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonitorRequest& from);
  void MergeFrom(const MonitorRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chirp.MonitorRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonitorReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chirp.MonitorReply) */ {
 public:
  MonitorReply();
  virtual ~MonitorReply();

  MonitorReply(const MonitorReply& from);

  inline MonitorReply& operator=(const MonitorReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonitorReply(MonitorReply&& from) noexcept
    : MonitorReply() {
    *this = ::std::move(from);
  }

  inline MonitorReply& operator=(MonitorReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorReply* internal_default_instance() {
    return reinterpret_cast<const MonitorReply*>(
               &_MonitorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MonitorReply* other);
  friend void swap(MonitorReply& a, MonitorReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonitorReply* New() const final {
    return CreateMaybeMessage<MonitorReply>(NULL);
  }

  MonitorReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonitorReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonitorReply& from);
  void MergeFrom(const MonitorReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chirp.Chirp chirp = 1;
  bool has_chirp() const;
  void clear_chirp();
  static const int kChirpFieldNumber = 1;
  private:
  const ::chirp::Chirp& _internal_chirp() const;
  public:
  const ::chirp::Chirp& chirp() const;
  ::chirp::Chirp* release_chirp();
  ::chirp::Chirp* mutable_chirp();
  void set_allocated_chirp(::chirp::Chirp* chirp);

  // @@protoc_insertion_point(class_scope:chirp.MonitorReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chirp::Chirp* chirp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chirp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PutRequest

// bytes key = 1;
inline void PutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:chirp.PutRequest.key)
  return key_.GetNoArena();
}
inline void PutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.PutRequest.key)
}
#if LANG_CXX11
inline void PutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.PutRequest.key)
}
#endif
inline void PutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.PutRequest.key)
}
inline void PutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.PutRequest.key)
}
inline ::std::string* PutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:chirp.PutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:chirp.PutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chirp.PutRequest.key)
}

// bytes value = 2;
inline void PutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:chirp.PutRequest.value)
  return value_.GetNoArena();
}
inline void PutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.PutRequest.value)
}
#if LANG_CXX11
inline void PutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.PutRequest.value)
}
#endif
inline void PutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.PutRequest.value)
}
inline void PutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.PutRequest.value)
}
inline ::std::string* PutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:chirp.PutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:chirp.PutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:chirp.PutRequest.value)
}

// -------------------------------------------------------------------

// PutReply

// -------------------------------------------------------------------

// GetRequest

// bytes key = 1;
inline void GetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:chirp.GetRequest.key)
  return key_.GetNoArena();
}
inline void GetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.GetRequest.key)
}
#if LANG_CXX11
inline void GetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.GetRequest.key)
}
#endif
inline void GetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.GetRequest.key)
}
inline void GetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.GetRequest.key)
}
inline ::std::string* GetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:chirp.GetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:chirp.GetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chirp.GetRequest.key)
}

// -------------------------------------------------------------------

// GetReply

// bytes value = 1;
inline void GetReply::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetReply::value() const {
  // @@protoc_insertion_point(field_get:chirp.GetReply.value)
  return value_.GetNoArena();
}
inline void GetReply::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.GetReply.value)
}
#if LANG_CXX11
inline void GetReply::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.GetReply.value)
}
#endif
inline void GetReply::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.GetReply.value)
}
inline void GetReply::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.GetReply.value)
}
inline ::std::string* GetReply::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:chirp.GetReply.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetReply::release_value() {
  // @@protoc_insertion_point(field_release:chirp.GetReply.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetReply::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:chirp.GetReply.value)
}

// -------------------------------------------------------------------

// DeleteRequest

// bytes key = 1;
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:chirp.DeleteRequest.key)
  return key_.GetNoArena();
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.DeleteRequest.key)
}
#if LANG_CXX11
inline void DeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.DeleteRequest.key)
}
#endif
inline void DeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:chirp.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:chirp.DeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chirp.DeleteRequest.key)
}

// -------------------------------------------------------------------

// DeleteReply

// -------------------------------------------------------------------

// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:chirp.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:chirp.Timestamp.seconds)
}

// int64 useconds = 2;
inline void Timestamp::clear_useconds() {
  useconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::useconds() const {
  // @@protoc_insertion_point(field_get:chirp.Timestamp.useconds)
  return useconds_;
}
inline void Timestamp::set_useconds(::google::protobuf::int64 value) {
  
  useconds_ = value;
  // @@protoc_insertion_point(field_set:chirp.Timestamp.useconds)
}

// -------------------------------------------------------------------

// Chirp

// string username = 1;
inline void Chirp::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::username() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.username)
  return username_.GetNoArena();
}
inline void Chirp::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.username)
}
#if LANG_CXX11
inline void Chirp::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.username)
}
#endif
inline void Chirp::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.username)
}
inline void Chirp::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.username)
}
inline ::std::string* Chirp::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_username() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.username)
}

// string text = 2;
inline void Chirp::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::text() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.text)
  return text_.GetNoArena();
}
inline void Chirp::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.text)
}
#if LANG_CXX11
inline void Chirp::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.text)
}
#endif
inline void Chirp::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.text)
}
inline void Chirp::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.text)
}
inline ::std::string* Chirp::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_text() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.text)
}

// bytes id = 3;
inline void Chirp::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::id() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.id)
  return id_.GetNoArena();
}
inline void Chirp::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.id)
}
#if LANG_CXX11
inline void Chirp::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.id)
}
#endif
inline void Chirp::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.id)
}
inline void Chirp::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.id)
}
inline ::std::string* Chirp::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_id() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.id)
}

// bytes parent_id = 4;
inline void Chirp::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::parent_id() const {
  // @@protoc_insertion_point(field_get:chirp.Chirp.parent_id)
  return parent_id_.GetNoArena();
}
inline void Chirp::set_parent_id(const ::std::string& value) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.Chirp.parent_id)
}
#if LANG_CXX11
inline void Chirp::set_parent_id(::std::string&& value) {
  
  parent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.Chirp.parent_id)
}
#endif
inline void Chirp::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.Chirp.parent_id)
}
inline void Chirp::set_parent_id(const void* value, size_t size) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.Chirp.parent_id)
}
inline ::std::string* Chirp::mutable_parent_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_parent_id() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.parent_id)
  
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    
  } else {
    
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.parent_id)
}

// .chirp.Timestamp timestamp = 5;
inline bool Chirp::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void Chirp::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
}
inline const ::chirp::Timestamp& Chirp::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::chirp::Timestamp& Chirp::timestamp() const {
  const ::chirp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:chirp.Chirp.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Timestamp*>(
      &::chirp::_Timestamp_default_instance_);
}
inline ::chirp::Timestamp* Chirp::release_timestamp() {
  // @@protoc_insertion_point(field_release:chirp.Chirp.timestamp)
  
  ::chirp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::chirp::Timestamp* Chirp::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.Chirp.timestamp)
  return timestamp_;
}
inline void Chirp::set_allocated_timestamp(::chirp::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timestamp_;
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:chirp.Chirp.timestamp)
}

// -------------------------------------------------------------------

// RegisterRequest

// string username = 1;
inline void RegisterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.RegisterRequest.username)
  return username_.GetNoArena();
}
inline void RegisterRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.RegisterRequest.username)
}
#if LANG_CXX11
inline void RegisterRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.RegisterRequest.username)
}
#endif
inline void RegisterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.RegisterRequest.username)
}
inline void RegisterRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.RegisterRequest.username)
}
inline ::std::string* RegisterRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.RegisterRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.RegisterRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.RegisterRequest.username)
}

// -------------------------------------------------------------------

// RegisterReply

// -------------------------------------------------------------------

// ChirpRequest

// string username = 1;
inline void ChirpRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.username)
  return username_.GetNoArena();
}
inline void ChirpRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.username)
}
#if LANG_CXX11
inline void ChirpRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.username)
}
#endif
inline void ChirpRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.username)
}
inline void ChirpRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.username)
}
inline ::std::string* ChirpRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.username)
}

// string text = 2;
inline void ChirpRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::text() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.text)
  return text_.GetNoArena();
}
inline void ChirpRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.text)
}
#if LANG_CXX11
inline void ChirpRequest::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.text)
}
#endif
inline void ChirpRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.text)
}
inline void ChirpRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.text)
}
inline ::std::string* ChirpRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_text() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.text)
}

// bytes parent_id = 3;
inline void ChirpRequest::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChirpRequest::parent_id() const {
  // @@protoc_insertion_point(field_get:chirp.ChirpRequest.parent_id)
  return parent_id_.GetNoArena();
}
inline void ChirpRequest::set_parent_id(const ::std::string& value) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ChirpRequest.parent_id)
}
#if LANG_CXX11
inline void ChirpRequest::set_parent_id(::std::string&& value) {
  
  parent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ChirpRequest.parent_id)
}
#endif
inline void ChirpRequest::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ChirpRequest.parent_id)
}
inline void ChirpRequest::set_parent_id(const void* value, size_t size) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ChirpRequest.parent_id)
}
inline ::std::string* ChirpRequest::mutable_parent_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ChirpRequest.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChirpRequest::release_parent_id() {
  // @@protoc_insertion_point(field_release:chirp.ChirpRequest.parent_id)
  
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChirpRequest::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    
  } else {
    
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpRequest.parent_id)
}

// -------------------------------------------------------------------

// ChirpReply

// .chirp.Chirp chirp = 1;
inline bool ChirpReply::has_chirp() const {
  return this != internal_default_instance() && chirp_ != NULL;
}
inline void ChirpReply::clear_chirp() {
  if (GetArenaNoVirtual() == NULL && chirp_ != NULL) {
    delete chirp_;
  }
  chirp_ = NULL;
}
inline const ::chirp::Chirp& ChirpReply::_internal_chirp() const {
  return *chirp_;
}
inline const ::chirp::Chirp& ChirpReply::chirp() const {
  const ::chirp::Chirp* p = chirp_;
  // @@protoc_insertion_point(field_get:chirp.ChirpReply.chirp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Chirp*>(
      &::chirp::_Chirp_default_instance_);
}
inline ::chirp::Chirp* ChirpReply::release_chirp() {
  // @@protoc_insertion_point(field_release:chirp.ChirpReply.chirp)
  
  ::chirp::Chirp* temp = chirp_;
  chirp_ = NULL;
  return temp;
}
inline ::chirp::Chirp* ChirpReply::mutable_chirp() {
  
  if (chirp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Chirp>(GetArenaNoVirtual());
    chirp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.ChirpReply.chirp)
  return chirp_;
}
inline void ChirpReply::set_allocated_chirp(::chirp::Chirp* chirp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chirp_;
  }
  if (chirp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chirp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chirp, submessage_arena);
    }
    
  } else {
    
  }
  chirp_ = chirp;
  // @@protoc_insertion_point(field_set_allocated:chirp.ChirpReply.chirp)
}

// -------------------------------------------------------------------

// FollowRequest

// string username = 1;
inline void FollowRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.FollowRequest.username)
  return username_.GetNoArena();
}
inline void FollowRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.FollowRequest.username)
}
#if LANG_CXX11
inline void FollowRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.FollowRequest.username)
}
#endif
inline void FollowRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.FollowRequest.username)
}
inline void FollowRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.FollowRequest.username)
}
inline ::std::string* FollowRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.FollowRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.FollowRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.FollowRequest.username)
}

// string to_follow = 2;
inline void FollowRequest::clear_to_follow() {
  to_follow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowRequest::to_follow() const {
  // @@protoc_insertion_point(field_get:chirp.FollowRequest.to_follow)
  return to_follow_.GetNoArena();
}
inline void FollowRequest::set_to_follow(const ::std::string& value) {
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.FollowRequest.to_follow)
}
#if LANG_CXX11
inline void FollowRequest::set_to_follow(::std::string&& value) {
  
  to_follow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.FollowRequest.to_follow)
}
#endif
inline void FollowRequest::set_to_follow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.FollowRequest.to_follow)
}
inline void FollowRequest::set_to_follow(const char* value, size_t size) {
  
  to_follow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.FollowRequest.to_follow)
}
inline ::std::string* FollowRequest::mutable_to_follow() {
  
  // @@protoc_insertion_point(field_mutable:chirp.FollowRequest.to_follow)
  return to_follow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowRequest::release_to_follow() {
  // @@protoc_insertion_point(field_release:chirp.FollowRequest.to_follow)
  
  return to_follow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowRequest::set_allocated_to_follow(::std::string* to_follow) {
  if (to_follow != NULL) {
    
  } else {
    
  }
  to_follow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_follow);
  // @@protoc_insertion_point(field_set_allocated:chirp.FollowRequest.to_follow)
}

// -------------------------------------------------------------------

// FollowReply

// -------------------------------------------------------------------

// ReadRequest

// bytes chirp_id = 1;
inline void ReadRequest::clear_chirp_id() {
  chirp_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::chirp_id() const {
  // @@protoc_insertion_point(field_get:chirp.ReadRequest.chirp_id)
  return chirp_id_.GetNoArena();
}
inline void ReadRequest::set_chirp_id(const ::std::string& value) {
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.ReadRequest.chirp_id)
}
#if LANG_CXX11
inline void ReadRequest::set_chirp_id(::std::string&& value) {
  
  chirp_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.ReadRequest.chirp_id)
}
#endif
inline void ReadRequest::set_chirp_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.ReadRequest.chirp_id)
}
inline void ReadRequest::set_chirp_id(const void* value, size_t size) {
  
  chirp_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.ReadRequest.chirp_id)
}
inline ::std::string* ReadRequest::mutable_chirp_id() {
  
  // @@protoc_insertion_point(field_mutable:chirp.ReadRequest.chirp_id)
  return chirp_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_chirp_id() {
  // @@protoc_insertion_point(field_release:chirp.ReadRequest.chirp_id)
  
  return chirp_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_chirp_id(::std::string* chirp_id) {
  if (chirp_id != NULL) {
    
  } else {
    
  }
  chirp_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chirp_id);
  // @@protoc_insertion_point(field_set_allocated:chirp.ReadRequest.chirp_id)
}

// -------------------------------------------------------------------

// ReadReply

// repeated .chirp.Chirp chirps = 1;
inline int ReadReply::chirps_size() const {
  return chirps_.size();
}
inline void ReadReply::clear_chirps() {
  chirps_.Clear();
}
inline ::chirp::Chirp* ReadReply::mutable_chirps(int index) {
  // @@protoc_insertion_point(field_mutable:chirp.ReadReply.chirps)
  return chirps_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >*
ReadReply::mutable_chirps() {
  // @@protoc_insertion_point(field_mutable_list:chirp.ReadReply.chirps)
  return &chirps_;
}
inline const ::chirp::Chirp& ReadReply::chirps(int index) const {
  // @@protoc_insertion_point(field_get:chirp.ReadReply.chirps)
  return chirps_.Get(index);
}
inline ::chirp::Chirp* ReadReply::add_chirps() {
  // @@protoc_insertion_point(field_add:chirp.ReadReply.chirps)
  return chirps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chirp::Chirp >&
ReadReply::chirps() const {
  // @@protoc_insertion_point(field_list:chirp.ReadReply.chirps)
  return chirps_;
}

// -------------------------------------------------------------------

// MonitorRequest

// string username = 1;
inline void MonitorRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MonitorRequest::username() const {
  // @@protoc_insertion_point(field_get:chirp.MonitorRequest.username)
  return username_.GetNoArena();
}
inline void MonitorRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chirp.MonitorRequest.username)
}
#if LANG_CXX11
inline void MonitorRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chirp.MonitorRequest.username)
}
#endif
inline void MonitorRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chirp.MonitorRequest.username)
}
inline void MonitorRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chirp.MonitorRequest.username)
}
inline ::std::string* MonitorRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chirp.MonitorRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MonitorRequest::release_username() {
  // @@protoc_insertion_point(field_release:chirp.MonitorRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MonitorRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chirp.MonitorRequest.username)
}

// -------------------------------------------------------------------

// MonitorReply

// .chirp.Chirp chirp = 1;
inline bool MonitorReply::has_chirp() const {
  return this != internal_default_instance() && chirp_ != NULL;
}
inline void MonitorReply::clear_chirp() {
  if (GetArenaNoVirtual() == NULL && chirp_ != NULL) {
    delete chirp_;
  }
  chirp_ = NULL;
}
inline const ::chirp::Chirp& MonitorReply::_internal_chirp() const {
  return *chirp_;
}
inline const ::chirp::Chirp& MonitorReply::chirp() const {
  const ::chirp::Chirp* p = chirp_;
  // @@protoc_insertion_point(field_get:chirp.MonitorReply.chirp)
  return p != NULL ? *p : *reinterpret_cast<const ::chirp::Chirp*>(
      &::chirp::_Chirp_default_instance_);
}
inline ::chirp::Chirp* MonitorReply::release_chirp() {
  // @@protoc_insertion_point(field_release:chirp.MonitorReply.chirp)
  
  ::chirp::Chirp* temp = chirp_;
  chirp_ = NULL;
  return temp;
}
inline ::chirp::Chirp* MonitorReply::mutable_chirp() {
  
  if (chirp_ == NULL) {
    auto* p = CreateMaybeMessage<::chirp::Chirp>(GetArenaNoVirtual());
    chirp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chirp.MonitorReply.chirp)
  return chirp_;
}
inline void MonitorReply::set_allocated_chirp(::chirp::Chirp* chirp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chirp_;
  }
  if (chirp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chirp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chirp, submessage_arena);
    }
    
  } else {
    
  }
  chirp_ = chirp;
  // @@protoc_insertion_point(field_set_allocated:chirp.MonitorReply.chirp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chirp

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_chirp_2eproto
